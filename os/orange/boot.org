* 概述
1. 准备
   1. 准备一张软盘,并将boot.bin, loader.bin和kernel.bin写入
   2. 将hdboot.bin写入硬盘某个分区的首扇区(VBR)
   3. 将hdldr.bin,kernel.bin和ls, touch等应用程序一起打包成inst.tar并写入硬盘相应位置
2. 先设置BIOS通过软盘启动. 
   1. 通过软盘启动后,控制权会依次转移boot->loader->kernel
   2. 进入kernel后, FS进程会执行mkfs()来初始化orange FS, 即在硬盘上写入FS相关元数据.
   3. 解压inst.tar到硬盘上,并维护FS相关的元数据.
3. 重启并通过硬盘相应分区的VBR启动
   1. hdboot会根据软盘启动时写入的FS元数据信息,从硬盘查找并加载hdldr
   2. hdldr同样从硬盘查找并加载kernel,然后系统就可以正常使用了.
* 软盘启动
** boot.asm
1. 被BIOS加载到物理地址0x7c00
2. 从软盘查找并加载loader.bin
3. 跳入loader.bin
** loader.asm
1. 被加载到物理地址0x90100
2. 定义GDT和GdtPtr. GDT包括三个段:代码段,数据段和显存段.其中代码段和数据段是扁平的(0-4G)
3. 获取可用的内存范围
4. 从软盘查找并读取kernel.bin到物理地址70000h处
5. 将硬盘引导扇区内容读到0x500h处
6. 进入保护模式(加载GDTR, 关中断, 打开A20地址线, cr0的最低位置1, 最后通过jmp指令进入保护模式)
7. 开启分页机制(SetUpPaging)
8. 按照ELF格式,重新放置kernel.bin(链接生成kernel.bin时,指定了-Ttext=0x1000)
9. 初始化位于0x900处的BOOT_PARAM_ADDR.
   该处依次存放魔数, 最大的连续可用内存数, 和kernel.bin实际被加载到的地址(0x70000)
10. 跳入内核执行
* 硬盘启动
** hdboot.asm
1. 被BIOS加载到物理地址0x7c00
2. 从ROOT_BASE指定的硬盘地址处,读取super_block到(0x700)
3. 
4. 读取软盘启动时初始化好的FS元数据(super_block等)来查找hdldr.bin
5. 将hdldr.bin加载到内存并跳入执行
** hdldr.asm


* 内核
* kernel.asm
1. 根据ELF默认定义,从_start处开始执行
2. 将esp指向kernel.bin的bss段中
3. sgdt [gdt_ptr]
4. 调用start.c的cstart()
   1. 先将gdt_ptr的base指针指向的内容copy到位于kernel中的gdt变量中，并将gdt_ptr中的base修改为指向gdt
   2. 将idt_ptr的base指向idt
   3. 调用protect.c的init_prot()
      1. 调用i8259.c的init_8259()以完成8259芯片的简单初始化
         1. 将8259A的主片的中断号设置为32-39,从片的中断号设置为40-47
         2. 将irq_table中的实际中断处理函数全部设置为简单打印中断号
      2. 初始化idt, 重点是8259A对应的32-47号中断和系统调用0x90号中断(相当于linux的0x80)
         1. 0-32号中断是intel定义的,32-255号中断可以由用户自定义
         2. 32-47号中断被设置为调用irq_table[中断号-32], 0x90号中断对应sys_call
         3. 这里由于主片和从片的EOI操作不同,所以使用了hwint_master和hwint_slave两个宏
      3. 初始化tss, 设置ring0的ss为SELECTOR_KERNEL_DS; 并添加tss描述符到gdt
      4. 为每个任务或用户进程添加一个ldt描述符到gdt,并将ldt的基址统一设置为SELECTOR_KERNEL_DS
5. lgdt [gdt_ptr]
6. lidt [idt_ptr]
7. 通过一个跳转指令使刚刚加载的gdt生效
8. 加载之前初始化的tss
9. jmp kernel_main
* main.c
1. 根据task_table和user_proc_table中的内容初始化proc_table中保存的PROCESS结构
   1. p_name, regs.eip从task结构中相应域copy
   2. 递增设置pid, idt_sel, regs.esp
   3. ldts =[0]= = gdt[SELECTOR_KERNEL_CS], ldts =[1]= = gdt[SELECTOR_KERNEL_DS]
   4. regs.cs对应自己的ldts =[0]= 即: SELECTOR_KERNEL_CS;
   5. regs.ds/es/fs/ss都对应自己的ldts =[1]= , 即: SELECTOR_KERNEL_DS
   6. regs.gs对应gdt中的SELECTOR_KERNEL_GS
   7. IPC相关的域, 如p_msg, p_sendto均设为null
   8. 打开的文件指针数组filp的每个成员也设为null
   9. k_reenter=0, p_proc_ready=proc_table
2. 调用clock.c的init_clock()
   1. disable_irq(CLOCK_IRQ)
   2. irq_table[CLOCK_IRQ] = clock_handler
   3. enable_irq(CLOCK_IRQ)
3. 调用keyboard.c的init_keyboard(): 类似init_clock,irq_table[KEYBOARD_IRQ] = keyboard_handler
4. 调用restart()
   #+BEGIN_SRC asm
restart:
       mov esp, [p_proc_ready]
       lldt    [esp + P_LDT_SEL] 
       lea eax, [esp + P_STACKTOP]
       mov dword [tss + TSS3_S_SP0], eax
restart_reenter:
       dec dword [k_reenter]
       pop gs
       pop fs
       pop es
       pop ds
       popad
       add esp, 4
       iretd
   #+END_SRC
5. while(1) {}