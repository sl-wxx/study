#+OPTIONS: ^:nil
* 硬件中断
** 初始化

1. 8259A主片32-39号中断对应的中断例程初始化为hwint_master, 代码如下:

      #+BEGIN_SRC asm
%macro	hwint_master	1
	call	save
	in	al, INT_M_CTLMASK	; `.
	or	al, (1 << %1)		;  | 屏蔽当前中断
	out	INT_M_CTLMASK, al	; /
	mov	al, EOI			; `. 置EOI位
	out	INT_M_CTL, al		; /
	sti	; CPU在响应中断的过程中会自动关中断，这句之后就允许响应新的中断
	push	%1			; `.
	call	[irq_table + 4 * %1]	;  | 中断处理程序
	pop	ecx			; /
	cli
	in	al, INT_M_CTLMASK	; `.
	and	al, ~(1 << %1)		;  | 恢复接受当前中断
	out	INT_M_CTLMASK, al	; /
	ret
%endmacro

save:
        pushad          ; `.
        push    ds      ;  |
        push    es      ;  | 保存原寄存器值
        push    fs      ;  |
        push    gs      ; /
        mov     dx, ss
        mov     ds, dx
        mov     es, dx

        mov     esi, esp                    ;esi = 进程表起始地址

        inc     dword [k_reenter]           ;k_reenter++;
        cmp     dword [k_reenter], 0        ;if(k_reenter ==0)
        jne     .1                          ;{
        mov     esp, StackTop               ;  mov esp, StackTop <--切换到内核栈
        push    restart                     ;  push restart
        jmp     [esi + RETADR - P_STACKBASE];  return;
.1:                                         ;} else { 已经在内核栈，不需要再切换
        push    restart_reenter             ;  push restart_reenter
        jmp     [esi + RETADR - P_STACKBASE];  return;
                                            ;}
restart:
	mov	esp, [p_proc_ready]
	lldt	[esp + P_LDT_SEL] 
	lea	eax, [esp + P_STACKTOP]
	mov	dword [tss + TSS3_S_SP0], eax
restart_reenter:
	dec	dword [k_reenter]
	pop	gs
	pop	fs
	pop	es
	pop	ds
	popad
	add	esp, 4
	iretd
      #+END_SRC

** 中断处理框架分析

1. 初始化过程会将idt中的中断例程设置为 hwint_master 0
   irq_table =[0]= 设置为 clock_handler,并向8259A发送信号打开时钟中断
2. 中断发生时, CPU会暂存用户进程的ss和esp, 从tss中读取ring0对应的ss0和esp0并切换到内核栈(即: ss0:esp0).
   然后将用户进程的ss,esp,eflags,cs,eip依次压栈,最后开始执行中断例程
3. 由于tss中的esp0恰好指向PCB的栈帧末尾,2中的步骤恰好使得用户进程的ss,esp,eflags,cs,eip被保存到PCB中
   #+BEGIN_SRC c

// PCB结构的栈帧定义
typedef struct s_stackframe {	/* proc_ptr points here				↑ Low			*/
	u32	gs;		/* ┓						│			*/
	u32	fs;		/* ┃						│			*/
	u32	es;		/* ┃						│			*/
	u32	ds;		/* ┃						│			*/
	u32	edi;		/* ┃						│			*/
	u32	esi;		/* ┣ pushed by save()				│			*/
	u32	ebp;		/* ┃						│			*/
	u32	kernel_esp;	/* <- 'popad' will ignore it			│			*/
	u32	ebx;		/* ┃						↑栈从高地址往低地址增长*/		
	u32	edx;		/* ┃						│			*/
	u32	ecx;		/* ┃						│			*/
	u32	eax;		/* ┛						│			*/
	u32	retaddr;	/* return address for assembly code save()	│			*/
	u32	eip;		/*  ┓						│			*/
	u32	cs;		/*  ┃						│			*/
	u32	eflags;		/*  ┣ these are pushed by CPU during interrupt	│			*/
	u32	esp;		/*  ┃						│			*/
	u32	ss;		/*  ┛						┷High			*/
}STACK_FRAME;
   #+END_SRC
4. 中断例程首先调用save方法
      #+BEGIN_SRC asm
save:
        pushad          ; `.
        push    ds      ;  |
        push    es      ;  | 保存原寄存器值
        push    fs      ;  |
        push    gs      ; /
        mov     dx, ss
        mov     ds, dx
        mov     es, dx

        mov     esi, esp                    ;esi = 进程表起始地址

        inc     dword [k_reenter]           ;k_reenter++;
        cmp     dword [k_reenter], 0        ;if(k_reenter ==0)
        jne     .1                          ;{
        mov     esp, StackTop               ;  mov esp, StackTop <--切换到内核栈
        push    restart                     ;  push restart
        jmp     [esi + RETADR - P_STACKBASE];  return;
.1:                                         ;} else { 已经在内核栈，不需要再切换
        push    restart_reenter             ;  push restart_reenter
        jmp     [esi + RETADR - P_STACKBASE];  return;
                                            ;}      
      #+END_SRC
   1. call指令会将当前指令的下一条指令的地址放到栈上, 恰好对应PCB栈帧的retaddr
   2. save方法随后通过push指令将用户进程的通用寄存器保存到PCB中
   3. 临时保存esp到esi, 此时esp=esi=PCB栈帧的最低地址处
   4. 根据k_reenter判断是否中断重入
      1. 非中断重入: 切换到内核栈,并在退出中断例程前为进入用户进程做好准备
      2. 中断重入: 不存在特权级变换,不需要切换堆栈.此时内核栈上形成类似方法调用的结构
   5. 通过第3步保存的esp从save返回到中断例程 
5. 返回中断例程
   #+BEGIN_SRC asm
%macro	hwint_master	1
	call	save
	in	al, INT_M_CTLMASK	; `.
	or	al, (1 << %1)		;  | 屏蔽当前中断
	out	INT_M_CTLMASK, al	; /
	mov	al, EOI			; `. 置EOI位
	out	INT_M_CTL, al		; /
	sti	; CPU在响应中断的过程中会自动关中断，这句之后就允许响应新的中断
	push	%1			; `.
	call	[irq_table + 4 * %1]	;  | 中断处理程序
	pop	ecx			; /
	cli
	in	al, INT_M_CTLMASK	; `.
	and	al, ~(1 << %1)		;  | 恢复接受当前中断
	out	INT_M_CTLMASK, al	; /
	ret
%endmacro
   #+END_SRC
   1. 在执行实际的中断函数之前,先禁用当前中断,置EOI
   2. 恢复被CPU自动关闭的中断响应, 即执行实际的中断函数时,允许接收新的中断
      如果此时发生新的中断,则会进入中断重入逻辑.多个中断在内核栈上形成类似方法调用的结构,依次执行
   3. 实际调用中断处理函数
   4. 关闭中断响应, 即: 下面的代码不能在可能产生中断的情况下执行
   5. 恢复接收当前中断
   6. 执行ret. 中断重入时,返回restart_reenter处;非中断重入时,返回restart
6. 返回用户进程或之前的中断
   #+BEGIN_SRC asm
restart:
	mov	esp, [p_proc_ready]
	lldt	[esp + P_LDT_SEL] 
	lea	eax, [esp + P_STACKTOP]
	mov	dword [tss + TSS3_S_SP0], eax
restart_reenter:
	dec	dword [k_reenter]
	pop	gs
	pop	fs
	pop	es
	pop	ds
	popad
	add	esp, 4
	iretd   
   #+END_SRC
   1. 非中断重入时,将esp指向用户进程PCB,这样之后的pop恰好是从PCB恢复之前保存的寄存器
      再将tss的sp0指向PCB中栈帧的末尾,以保证下次中断发生时,用户进程的寄存器恰好保存在PCB中
   2. iretd 指令会从当前堆栈上依次恢复eip,cs,eflags; 如果存在特权级变换同时恢复esp和ss
      恢复eflags会将if位置1, 重新接收中断

** 中断重入分析
1. 中断发生时,CPU会自动关闭中断响应. 所以只有sti和cli之间的代码: 即实际的中断处理函数可能会被中断
2. 实际的中断处理函数被中断时,新的中断处理例程进入中断重入逻辑.
3. 先是旧中断的eflags,cs,eip被压到内核栈上
4. 然后新中断例程的save方法会把旧中断的段寄存器和通用寄存器压到内核栈上
5. 最后新的中断例程开始执行自己的中断处理函数
6. 新中断例程的iretd指令会恢复eflags,重新接收中断.
7. 此时旧中断例程可能再次被中断,但不会被相同类型的中断打断(旧中断类型的中断被相关代码屏蔽)
8. 旧中断例程恢复执行

总体上, 多个中断在内核栈上形成了类似方法调用的结构,依次执行

** 时钟中断分析
#+BEGIN_SRC c
PUBLIC void clock_handler(int irq)
{
    ticks++;
    p_proc_ready->ticks--;

    if (k_reenter != 0) {  // 中断重入,此时CPU在处理中断,不执行进程切换
        return;
    }
    if (p_proc_ready->ticks > 0) {
        return;
    }

    schedule();
}

PUBLIC void schedule()
{
    PROCESS* p;
    int  greatest_ticks = 0;

    while (!greatest_ticks) {
        for (p = proc_table; p < proc_table+NR_TASKS+NR_PROCS; p++) {
            if (p->ticks > greatest_ticks) {
                greatest_ticks = p->ticks;
                p_proc_ready = p;
            }
        }

        if (!greatest_ticks) {
            for(p=proc_table;p<proc_table+NR_TASKS+NR_PROCS;p++) {
                p->ticks = p->priority;
            }
        }
    }
}
#+END_SRC

1. 时钟中断主要做了两件事情: ticks++ 和 当前用户进程时间片--
2. 如果当前用户进程时间片用尽,切换进程(schedule)
3. schedule主要是修改了p_proc_ready,结合restart处的代码即可完成进程切换

* 软中断与系统调用
系统调用是通过软中断实现的, 即int指令. 
** 初始化
1. 在idt中将中断号0x90和sys_call建立关联
2. 初始化sys_call_table: 
   sys_call_table[NR_SYS_CALL] = {sys_get_ticks, sys_write}
** 系统调用接口
   #+BEGIN_SRC asm
write:
        mov     eax, _NR_write
        mov     ebx, [esp + 4]
        mov     ecx, [esp + 8]
        int     INT_VECTOR_SYS_CALL
        ret
   #+END_SRC
1. eax传递系统调用号, ebx和ecx传递另外2个参数
2. 通过int指令调用0x90对应的中断例程sys_call
** 系统调用实现
#+BEGIN_SRC asm
sys_call:
    call    save
    push    dword [p_proc_ready]
    sti

    push    ecx
    push    ebx
    call    [sys_call_table + eax * 4]
    add     esp, 4 * 3

    mov     [esi + EAXREG - P_STACKBASE], eax
    cli
    ret
;;  实际系统调用函数的签名(sys_call_table + eax*4)
;;  PUBLIC int sys_write(char* buf, int len, PROCESS* p_proc)
#+END_SRC
1. 先调用save方法保存用户进程的寄存器并切换到内核栈
2. 将参数p_proc_ready,ecx和ebx压栈,并调用实际的系统调用函数.
3. p_proc_ready表示调用系统调用的用户进程.
4. 按照默认的函数调用惯例,返回值大小在1-4字节时,通过eax返回;在5-8字节时, 通过eax+ebx返回
5. 参数出栈,并将保存在eax中的返回值赋给用户进程的PCB中的eax 
   这样在iretd执行完之后,通过从PCB中恢复eax即可得到系统调用的返回值
6. 返回restart处执行