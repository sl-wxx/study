* 概述
| offset | interpreter                         | native    | entry               |
|--------+-------------------------------------+-----------+---------------------|
|     -8 | initial_sp    : expression stack sp |           |                     |
|     -7 | bcx (r13)     : bytecode pointer    |           |                     |
|     -6 | locals (r14)  : locals pointer      |           | call_wrapper_offset |
|     -5 | cpCache       : constant pool cache |           |                     |
|     -4 | mdx           : methodData pointer  |           |                     |
|     -3 | Method*       :                     |           |                     |
|     -2 | last_sp       :                     |           |                     |
|     -1 | caller rsp    : sender_sp           |           |                     |
|      0 | caller rbp/FP : FP points to here.  | old rbp   | arg_reg_save_area   |
|      1 | return pc     :                     | return pc | return pc           |
|      2 | oop temp      :                     | args      | sender_sp           |
|      3 | result handler:                     | args      |                     |
|      4 | locals & args :                     | args      |                     |
|        | sender_sp points to here            |           |                     |

1. 对所有类型的frame, offset为1的位置是返回地址, 由call指令push到栈上.
2. offset为1的位置对entry类型以外的frame都是调用者的rbp, 这符合传统的函数调用惯例.
3. interpreter frame 在传统函数调用惯例的基础上进行了扩展添加和很多其他的内容.
4. native frame 完全符合传统调用惯例.
5. entry frame本身并不是一个完整的frame, 所以没有自己的rbp/fp.
* 源码
            #+BEGIN_SRC c++
// A frame represents a physical stack frame (an activation).  Frames can be
// C or Java frames, and the Java frames can be interpreted or compiled.
// In contrast, vframes represent source-level activations, so that one physical frame
// can correspond to multiple source level frames because of inlining.
// A frame is comprised of {pc, fp, sp}
// ------------------------------ Asm interpreter ----------------------------------------
// Layout of asm interpreter frame:
//    [expression stack      ] * <- sp
//    [monitors              ]   \
//     ...                        | monitor block size
//    [monitors              ]   /
//    [monitor block size    ]
//    [byte code index/pointr]                   = bcx()                bcx_offset
//    [pointer to locals     ]                   = locals()             locals_offset
//    [constant pool cache   ]                   = cache()              cache_offset
//    [methodData            ]                   = mdp()                mdx_offset
//    [Method*               ]                   = method()             method_offset
//    [last sp               ]                   = last_sp()            last_sp_offset
//    [old stack pointer     ]                     (sender_sp)          sender_sp_offset
//    [old frame pointer     ]   <- fp           = link()
//    [return pc             ]
//    [oop temp              ]                     (only for native calls)
//    [locals and parameters ]
//                               <- sender sp
// ------------------------------ Asm interpreter ----------------------------------------

class frame VALUE_OBJ_CLASS_SPEC {
 private:
  // Instance variables:
  intptr_t* _sp; // stack pointer (from Thread::last_Java_sp)
  address   _pc; // program counter (the next instruction after the call)

  CodeBlob* _cb; // CodeBlob that "owns" pc
  enum deopt_state {
    not_deoptimized,
    is_deoptimized,
    unknown
  };

  deopt_state _deopt_state;
  
  // an additional field beyond _sp and _pc:
  intptr_t*   _fp; // frame pointer
  // The interpreter and adapters will extend the frame of the caller.
  // Since oopMaps are based on the sp of the caller before extension
  // we need to know that value. However in order to compute the address
  // of the return address we need the real "raw" sp. Since sparc already
  // uses sp() to mean "raw" sp and unextended_sp() to mean the caller's
  // original sp we use that convention.

  intptr_t*     _unextended_sp;
 public:
  enum {
    pc_return_offset                                 =  0,
    // All frames
    link_offset                                      =  0,
    return_addr_offset                               =  1,
    // non-interpreter frames
    sender_sp_offset                                 =  2,

    // Interpreter frames
    interpreter_frame_result_handler_offset          =  3, // for native calls only
    interpreter_frame_oop_temp_offset                =  2, // for native calls only

    interpreter_frame_sender_sp_offset               = -1,
    // outgoing sp before a call to an invoked method
    interpreter_frame_last_sp_offset                 = interpreter_frame_sender_sp_offset - 1,
    interpreter_frame_method_offset                  = interpreter_frame_last_sp_offset - 1,
    interpreter_frame_mdx_offset                     = interpreter_frame_method_offset - 1,
    interpreter_frame_cache_offset                   = interpreter_frame_mdx_offset - 1,
    interpreter_frame_locals_offset                  = interpreter_frame_cache_offset - 1,
    interpreter_frame_bcx_offset                     = interpreter_frame_locals_offset - 1,
    interpreter_frame_initial_sp_offset              = interpreter_frame_bcx_offset - 1,

    interpreter_frame_monitor_block_top_offset       = interpreter_frame_initial_sp_offset,
    interpreter_frame_monitor_block_bottom_offset    = interpreter_frame_initial_sp_offset,

    // Entry frames

    entry_frame_after_call_words                     = 13,
    entry_frame_call_wrapper_offset                  = -6,

    arg_reg_save_area_bytes                          =  0,

    // Native frames

    native_frame_initial_param_offset                =  2
  };
}            
            #+END_SRC