* 初始化流程概述
interpreter的初始化代码位于Threads::create_vm() ----> init_globals()方法中.

1. bytecodes_init() 初始化bytecode table.
2. interpreter_init()
   1. TemplateInterpreter::initialize()
      1. AbstractInterpreter::initialize(): 
         重置相关计数器, 如BytecodeCounter/BytecodeHistogram/InvocationCounter
      2. TemplateTable::initialize()
         将bytecode和用于解释它的generator函数对应起来
      3. 初始化InterpreterGenerator
         #+BEGIN_SRC c++
_code = new StubQueue(new InterpreterCodeletInterface, code_size, NULL, "Interpreter");
InterpreterGenerator g(_code);         
         #+END_SRC
         1. AbstractInterpreterGenerator::generate_all()
            Interpreter::_slow_signature_handler = generate_slow_signature_handler();
         2. TemplateInterpreterGenerator::generate_all()
            #+BEGIN_SRC c++
_unimplemented_bytecode    = generate_error_exit("unimplemented bytecode");
_illegal_bytecode_sequence = generate_error_exit("illegal bytecode sequence - method not verified");            
for (int i = 0; i < Interpreter::number_of_return_entries; i++) {
  Interpreter::_return_entry[i] =
    EntryPoint(
      generate_return_entry_for(itos, i, index_size),
      generate_return_entry_for(itos, i, index_size),
      generate_return_entry_for(itos, i, index_size),
      generate_return_entry_for(atos, i, index_size),
      generate_return_entry_for(itos, i, index_size),
      generate_return_entry_for(ltos, i, index_size),
      generate_return_entry_for(ftos, i, index_size),
      generate_return_entry_for(dtos, i, index_size),
      generate_return_entry_for(vtos, i, index_size)
    );
}

for (int i = 0; i < Interpreter::number_of_return_addrs; i++) {
  TosState state = states[i];
  Interpreter::_invoke_return_entry[i] = generate_return_entry_for(state, invoke_length, sizeof(u2));
  Interpreter::_invokeinterface_return_entry[i] = generate_return_entry_for(state, invokeinterface_length, sizeof(u2));
  Interpreter::_invokedynamic_return_entry[i] = generate_return_entry_for(state, invokedynamic_length, sizeof(u4));
}

Interpreter::_earlyret_entry =
  EntryPoint(
    generate_earlyret_entry_for(btos),
    generate_earlyret_entry_for(ctos),
    generate_earlyret_entry_for(stos),
    generate_earlyret_entry_for(atos),
    generate_earlyret_entry_for(itos),
    generate_earlyret_entry_for(ltos),
    generate_earlyret_entry_for(ftos),
    generate_earlyret_entry_for(dtos),
    generate_earlyret_entry_for(vtos)
  );  

for (int i = 0; i < Interpreter::number_of_deopt_entries; i++) {
  Interpreter::_deopt_entry[i] =
    EntryPoint(
      generate_deopt_entry_for(itos, i),
      generate_deopt_entry_for(itos, i),
      generate_deopt_entry_for(itos, i),
      generate_deopt_entry_for(atos, i),
      generate_deopt_entry_for(itos, i),
      generate_deopt_entry_for(ltos, i),
      generate_deopt_entry_for(ftos, i),
      generate_deopt_entry_for(dtos, i),
      generate_deopt_entry_for(vtos, i)
    );
}

for (int i = 0; i < Interpreter::number_of_result_handlers; i++) {
  BasicType type = types[i];
  if (!is_generated[Interpreter::BasicType_as_index(type)]++) {
    Interpreter::_native_abi_to_tosca[Interpreter::BasicType_as_index(type)] = generate_result_handler_for(type);
  }
}

Interpreter::_continuation_entry =
  EntryPoint(
    generate_continuation_for(btos),
    generate_continuation_for(ctos),
    generate_continuation_for(stos),
    generate_continuation_for(atos),
    generate_continuation_for(itos),
    generate_continuation_for(ltos),
    generate_continuation_for(ftos),
    generate_continuation_for(dtos),
    generate_continuation_for(vtos)
  );

Interpreter::_safept_entry =
  EntryPoint(
    generate_safept_entry_for(btos, CAST_FROM_FN_PTR(address, InterpreterRuntime::at_safepoint)),
    generate_safept_entry_for(ctos, CAST_FROM_FN_PTR(address, InterpreterRuntime::at_safepoint)),
    generate_safept_entry_for(stos, CAST_FROM_FN_PTR(address, InterpreterRuntime::at_safepoint)),
    generate_safept_entry_for(atos, CAST_FROM_FN_PTR(address, InterpreterRuntime::at_safepoint)),
    generate_safept_entry_for(itos, CAST_FROM_FN_PTR(address, InterpreterRuntime::at_safepoint)),
    generate_safept_entry_for(ltos, CAST_FROM_FN_PTR(address, InterpreterRuntime::at_safepoint)),
    generate_safept_entry_for(ftos, CAST_FROM_FN_PTR(address, InterpreterRuntime::at_safepoint)),
    generate_safept_entry_for(dtos, CAST_FROM_FN_PTR(address, InterpreterRuntime::at_safepoint)),
    generate_safept_entry_for(vtos, CAST_FROM_FN_PTR(address, InterpreterRuntime::at_safepoint))
  );

generate_throw_exception();

method_entry();

set_entry_points_for_all_bytes();
set_safepoints_for_all_bytes();
            #+END_SRC
         3. InterpreterGenerator::generate_all()
            #+begin_example
// A frame represents a physical stack frame (an activation).  Frames can be
// C or Java frames, and the Java frames can be interpreted or compiled.
// In contrast, vframes represent source-level activations, so that one physical frame
// can correspond to multiple source level frames because of inlining.
// A frame is comprised of {pc, fp, sp}
// ------------------------------ Asm interpreter ----------------------------------------
// Layout of asm interpreter frame:
//    [expression stack      ] * <- sp
//    [monitors              ]   \
//     ...                        | monitor block size
//    [monitors              ]   /
//    [monitor block size    ]
//    [byte code index/pointr]                   = bcx()                bcx_offset
//    [pointer to locals     ]                   = locals()             locals_offset
//    [constant pool cache   ]                   = cache()              cache_offset
//    [methodData            ]                   = mdp()                mdx_offset
//    [Method*               ]                   = method()             method_offset
//    [last sp               ]                   = last_sp()            last_sp_offset
//    [old stack pointer     ]                     (sender_sp)          sender_sp_offset
//    [old frame pointer     ]   <- fp           = link()
//    [return pc             ]
//    [oop temp              ]                     (only for native calls)
//    [locals and parameters ]
//                               <- sender sp
// ------------------------------ Asm interpreter ----------------------------------------
            #+end_example

            #+BEGIN_SRC c++
// A frame represents a physical stack frame (an activation).  Frames can be
// C or Java frames, and the Java frames can be interpreted or compiled.
// In contrast, vframes represent source-level activations, so that one physical frame
// can correspond to multiple source level frames because of inlining.
// A frame is comprised of {pc, fp, sp}
// ------------------------------ Asm interpreter ----------------------------------------
// Layout of asm interpreter frame:
//    [expression stack      ] * <- sp
//    [monitors              ]   \
//     ...                        | monitor block size
//    [monitors              ]   /
//    [monitor block size    ]
//    [byte code index/pointr]                   = bcx()                bcx_offset
//    [pointer to locals     ]                   = locals()             locals_offset
//    [constant pool cache   ]                   = cache()              cache_offset
//    [methodData            ]                   = mdp()                mdx_offset
//    [Method*               ]                   = method()             method_offset
//    [last sp               ]                   = last_sp()            last_sp_offset
//    [old stack pointer     ]                     (sender_sp)          sender_sp_offset
//    [old frame pointer     ]   <- fp           = link()
//    [return pc             ]
//    [oop temp              ]                     (only for native calls)
//    [locals and parameters ]
//                               <- sender sp
// ------------------------------ Asm interpreter ----------------------------------------

class frame VALUE_OBJ_CLASS_SPEC {
 private:
  // Instance variables:
  intptr_t* _sp; // stack pointer (from Thread::last_Java_sp)
  address   _pc; // program counter (the next instruction after the call)

  CodeBlob* _cb; // CodeBlob that "owns" pc
  enum deopt_state {
    not_deoptimized,
    is_deoptimized,
    unknown
  };

  deopt_state _deopt_state;
  
  // an additional field beyond _sp and _pc:
  intptr_t*   _fp; // frame pointer
  // The interpreter and adapters will extend the frame of the caller.
  // Since oopMaps are based on the sp of the caller before extension
  // we need to know that value. However in order to compute the address
  // of the return address we need the real "raw" sp. Since sparc already
  // uses sp() to mean "raw" sp and unextended_sp() to mean the caller's
  // original sp we use that convention.

  intptr_t*     _unextended_sp;
 public:
  enum {
    pc_return_offset                                 =  0,
    // All frames
    link_offset                                      =  0,
    return_addr_offset                               =  1,
    // non-interpreter frames
    sender_sp_offset                                 =  2,

    // Interpreter frames
    interpreter_frame_result_handler_offset          =  3, // for native calls only
    interpreter_frame_oop_temp_offset                =  2, // for native calls only

    interpreter_frame_sender_sp_offset               = -1,
    // outgoing sp before a call to an invoked method
    interpreter_frame_last_sp_offset                 = interpreter_frame_sender_sp_offset - 1,
    interpreter_frame_method_offset                  = interpreter_frame_last_sp_offset - 1,
    interpreter_frame_mdx_offset                     = interpreter_frame_method_offset - 1,
    interpreter_frame_cache_offset                   = interpreter_frame_mdx_offset - 1,
    interpreter_frame_locals_offset                  = interpreter_frame_cache_offset - 1,
    interpreter_frame_bcx_offset                     = interpreter_frame_locals_offset - 1,
    interpreter_frame_initial_sp_offset              = interpreter_frame_bcx_offset - 1,

    interpreter_frame_monitor_block_top_offset       = interpreter_frame_initial_sp_offset,
    interpreter_frame_monitor_block_bottom_offset    = interpreter_frame_initial_sp_offset,

    // Entry frames

    entry_frame_after_call_words                     = 13,
    entry_frame_call_wrapper_offset                  = -6,

    arg_reg_save_area_bytes                          =  0,

    entry_frame_call_wrapper_offset                  =  2,

    // Native frames

    native_frame_initial_param_offset                =  2
  };
}            
            #+END_SRC
* 源码分析

1. TemplateTable结构
   TemplateTable的主要成员是Template类型的数组_template_table/_template_table_wide. 
   Template保存了字节码相关的属性和一个函数指针generator.该函数用于生成字节码对应的汇编指令.
   #+BEGIN_SRC c++
class TemplateTable: AllStatic {
 public:
  enum Operation { add, sub, mul, div, rem, _and, _or, _xor, shl, shr, ushr };
  enum Condition { equal, not_equal, less, less_equal, greater, greater_equal };
  enum CacheByte { f1_byte = 1, f2_byte = 2 };  // byte_no codes

 private:
  static bool            _is_initialized;        // true if TemplateTable has been initialized
  static Template        _template_table     [Bytecodes::number_of_codes];
  static Template        _template_table_wide[Bytecodes::number_of_codes];

  static Template*       _desc;                  // the current template to be generated
 
  static BarrierSet*     _bs;                    // Cache the barrier set.
 public:
  //%note templates_1
  static InterpreterMacroAssembler* _masm;       // the assembler used when generating templates 
}   
   #+END_SRC
2. 初始化TemplateTable::_template_table/_template_table_wide
   def函数负责初始化_template_table数组的元素. 代码如下:
   #+BEGIN_SRC c++
void TemplateTable::initialize() {

  const char _    = ' ';
  const int  ____ = 0;

  //                         interpr. templates
  // Java spec bytecodes     ubcp|disp|clvm|iswd  in    out   generator    argument
  def(Bytecodes::_iconst_0,  ____|____|____|____, vtos, itos, iconst,      0           );
  def(Bytecodes::_iconst_1,  ____|____|____|____, vtos, itos, iconst,      1           );
  def(Bytecodes::_istore_0,  ____|____|____|____, itos, vtos, istore,      0           );
  def(Bytecodes::_istore_1,  ____|____|____|____, itos, vtos, istore,      1           );
  //..............
  //..............
}

// 上面的in和out都是TosState类型
// TosState describes the top-of-stack state before and after the execution of
// a bytecode or method. The top-of-stack value may be cached in one or more CPU
// registers. The TosState corresponds to the 'machine represention' of this cached
// value. There's 4 states corresponding to the JAVA types int, long, float & double
// as well as a 5th state in case the top-of-stack value is actually on the top
// of stack (in memory) and thus not cached. The atos state corresponds to the itos
// state when it comes to machine representation but is used separately for (oop)
// type specific operations (e.g. verification code).

enum TosState {         // describes the tos cache contents
  btos = 0,             // byte, bool tos cached
  ctos = 1,             // char tos cached
  stos = 2,             // short tos cached
  itos = 3,             // int tos cached
  ltos = 4,             // long tos cached
  ftos = 5,             // float tos cached
  dtos = 6,             // double tos cached
  atos = 7,             // object cached
  vtos = 8,             // tos not cached
  number_of_states,
  ilgl                  // illegal state: should not occur
};

typedef void (*generator)(int arg);
   #+END_SRC
3. 根据字节码生成汇编代码
   这里以iconst和istore为例分析.
   1. iconst_<i>
      1. 通过查阅JVMS可知iconst_<i>的含义为: 将数值i push到操作数栈.
      2. 根据源码易知其对应的汇编指令为: movl rax, i
      3. 其in=vtos表示不需要操作数栈提供参数, 其out=itos表示字节码执行结束后操作数栈顶是一个int值
      4. 可以看出, 在x86的特定实现中, 实际是使用通用寄存器模拟了一个操作数栈.
         #+BEGIN_SRC c++
#define __ _masm->   

void TemplateTable::iconst(int value) {
  transition(vtos, itos);
  if (value == 0) {
   __ xorl(rax, rax);
  } else {
   __ movl(rax, value);
  }
}

// 对应汇编代码 movl rax, imm32. 查阅intel开发手册可知, B8在机器码中表示mov
void Assembler::movl(Register dst, int32_t imm32) {
  int encode = prefix_and_encode(dst->encoding());
  emit_int8((unsigned char)(0xB8 | encode));
  emit_int32(imm32);
}         
         #+END_SRC
   2. istore_<i>
      1. istore_<i>的作用是将操作数栈顶的int值赋值给locals =[i]=
      2. 其in=itos表示需要操作数栈提供int型参数, out=vtos表示执行后对操作数栈无要求(没有向操作数栈push数据).
      3. 其对应的汇编代码类似: movl locals =[i]= , rax
      #+BEGIN_SRC c++
#define __ _masm->   

void TemplateTable::istore(int n) {
  transition(itos, vtos);
  __ movl(iaddress(n), rax);
}      

// r14: pointer to locals
static inline Address iaddress(int n) {
  return Address(r14, Interpreter::local_offset_in_bytes(n));
}

// Local values relative to locals[n]
static int  local_offset_in_bytes(int n) {
  return ((frame::interpreter_frame_expression_stack_direction() * n) * stackElementSize);
}

inline jint frame::interpreter_frame_expression_stack_direction() { return -1; }

      #+END_SRC


#+BEGIN_SRC c++
address AbstractInterpreterGenerator::generate_slow_signature_handler() {
  address entry = __ pc();

  // rbx: method
  // r14: pointer to locals
  // c_rarg3: first stack arg - wordSize
  __ mov(c_rarg3, rsp);
  // adjust rsp
  __ subptr(rsp, 14 * wordSize);
  __ call_VM(noreg,
             CAST_FROM_FN_PTR(address,
                              InterpreterRuntime::slow_signature_handler),
             rbx, r14, c_rarg3);

  // rax: result handler

  // Stack layout:
  // rsp: 5 integer args (if static first is unused)
  //      1 float/double identifiers
  //      8 double args
  //        return address
  //        stack args
  //        garbage
  //        expression stack bottom
  //        bcp (NULL)
  //        ...

  // Do FP first so we can use c_rarg3 as temp
  __ movl(c_rarg3, Address(rsp, 5 * wordSize)); // float/double identifiers

  for (int i = 0; i < Argument::n_float_register_parameters_c; i++) {
    const XMMRegister r = as_XMMRegister(i);

    Label d, done;

    __ testl(c_rarg3, 1 << i);
    __ jcc(Assembler::notZero, d);
    __ movflt(r, Address(rsp, (6 + i) * wordSize));
    __ jmp(done);
    __ bind(d);
    __ movdbl(r, Address(rsp, (6 + i) * wordSize));
    __ bind(done);
  }

  // Now handle integrals.  Only do c_rarg1 if not static.
  __ movl(c_rarg3, Address(rbx, Method::access_flags_offset()));
  __ testl(c_rarg3, JVM_ACC_STATIC);
  __ cmovptr(Assembler::zero, c_rarg1, Address(rsp, 0));

  __ movptr(c_rarg2, Address(rsp, wordSize));
  __ movptr(c_rarg3, Address(rsp, 2 * wordSize));
  __ movptr(c_rarg4, Address(rsp, 3 * wordSize));
  __ movptr(c_rarg5, Address(rsp, 4 * wordSize));

  // restore rsp
  __ addptr(rsp, 14 * wordSize);

  __ ret(0);

  return entry;
}
#+END_SRC