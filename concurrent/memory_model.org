* 概述
  1. 代码执行效率和编程接口复杂度是矛盾的.
  2. 通常接口越接近顺序执行, 人类理解起来就越简单, 但机器执行代码的效率就越低.
  3. 内存模型是这两者平衡的产物, 通过在两者之间取舍就可以得到各种各样的内存模型.

* 描述/理解内存模型

最简单也是效率最低的模型是顺序执行, 所以通过增加可以乱序执行的说明, 我们就把平衡点向效率一端移动了.
同样的, 最极端的内存模型是没有任何顺序, 通过增加必须遵守的顺序, 也就把平衡点向简单一端移动了.
内存模型就是通过说明什么场景可以乱序执行, 或者说什么场景必须顺序执行来描述平衡点的. 
这也是理解内存模型的关键. 具体到实际描述, 又可以分为2步:
  1. 先建立单线程(单核心)模型
     单线程模型相对简单, 通常都是要求程序执行的结果和顺序执行相同. 
  2. 再扩展到多线程(多核心)
     多线程模型下的场景又可以分为2类:
     1. 不影响其他线程的行为
        不影响其他线程的也很简单, 通常按单线程模型处理
     2. 影响其他线程的行为
        这一部分通常是一个具体的内存模型描述的重点. 要描述这一部分, 先要弄清楚会发生怎样的影响.
        以Java内存模型为例, 可能的影响有:
            1. 启动线程: 发生启动与被启动的联系
            2. 线程终止: 发生终止与被观察到终止的联系
            3. 共享变量: 又可以细分为共享普通变量, 共享volatile变量, 共享锁(锁可以简单理解为特殊变量)
            4. 其他.....
        内存模型只要对可能的影响逐一规定其顺序即可.
* 实例
  读者可以参照上述思路尝试理解Java内存模型和intel的多核心内存模型.
  内存模型的描述可以从《Java language specification》 和 《intel develop manual》中找到.
        